name: Build x64 MSIX Package

on:
  workflow_dispatch:
    inputs:
      source_branch:
        description: 'Branch from source repo to build'
        required: false
        default: 'main'
      version_tag:
        description: 'Version tag (optional - will use latest if not specified)'
        required: false
        default: ''

  push:
    branches: [ main ]
    paths:
      - 'msix/**'
      - '.github/workflows/**'

  schedule:
    - cron: '0 2 * * 1'  # Weekly builds on Monday at 2 AM UTC

env:
  SOURCE_REPO: 'dk107dk/flightpath'
  PYTHON_VERSION: '3.12'
  APP_NAME: 'FlightPathData'

jobs:
  build-x64:
    runs-on: windows-latest

    steps:
    - name: Checkout packaging repo
      uses: actions/checkout@v4
      with:
        path: packaging

    - name: Checkout source repo
      uses: actions/checkout@v4
      with:
        repository: ${{ env.SOURCE_REPO }}
        ref: ${{ github.event.inputs.source_branch || 'main' }}
        path: source
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        architecture: x64

    - name: Install and Configure Poetry
      shell: pwsh
      run: |
        pipx install poetry
        poetry --version
        cd source
        poetry config virtualenvs.create true
        poetry config virtualenvs.in-project true

    - name: Get version from source
      id: get_version
      shell: pwsh
      run: |
        cd source
        if ("${{ github.event.inputs.version_tag }}" -ne "") {
          $version = "${{ github.event.inputs.version_tag }}"
          git checkout "tags/$version"
        } else {
          $content = Get-Content pyproject.toml -Raw
          $version = [regex]::Match($content, 'version\s*=\s*"([^"]+)"').Groups[1].Value
        }
        echo "version=$version" >> $env:GITHUB_OUTPUT
        echo "Building version: $version"

    - name: Cache dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cache/pip
          source/.venv
        key: poetry-x64-${{ runner.os }}-${{ hashFiles('source/poetry.lock') }}
        restore-keys: |
          poetry-x64-${{ runner.os }}-

    - name: Overwrite poetry.lock
      shell: pwsh
      run: |
        Copy-Item -Path "$env:GITHUB_WORKSPACE/packaging/poetry.lock" -Destination "$env:GITHUB_WORKSPACE/source/poetry.lock"

    - name: Install dependencies
      shell: pwsh
      run: |
        cd source
        poetry install

    - name: Build executable
      shell: pwsh
      run: |
        cd source
        New-Item -ItemType Directory -Force -Path "dist/x64"

        # Create PyInstaller spec file
        $specLines = @(
          "import os",
          "# -*- mode: python ; coding: utf-8 -*-",
          "",
          "base_path = os.path.abspath('.')",
          "assets_path = os.path.join(base_path, 'flightpath', 'assets')",
          "icon_path = os.path.join(assets_path, 'icons', 'icon.ico')",
          "",
          "datas = []",
          "if os.path.exists(assets_path):",
          "    datas.append((assets_path, 'assets'))",
          "",
          "a = Analysis(",
          "    [os.path.join(base_path, 'flightpath', 'main.py')],",
          "    pathex=[],",
          "    binaries=[],",
          "    datas=datas,",
          "    hiddenimports=[],",
          "    hookspath=[],",
          "    hooksconfig={},",
          "    runtime_hooks=[],",
          "    excludes=[],",
          "    noarchive=False,",
          "    optimize=0,",
          ")",
          "pyz = PYZ(a.pure)",
          "exe = EXE(",
          "    pyz,",
          "    a.scripts,",
          "    a.binaries,",
          "    a.datas,",
          "    [],",
          "    name='FlightPathData',",
          "    debug=False,",
          "    strip=False,",
          "    upx=True,",
          "    upx_exclude=[],",
          "    runtime_tmpdir=None,",
          "    console=False,",
          "    disable_windowed_traceback=False,",
          "    icon=icon_path if os.path.exists(icon_path) else None,",
          ")"
        )

        $specLines | Out-File -FilePath "flightpath_ci.spec" -Encoding utf8

        poetry run python -m PyInstaller `
          --distpath "dist/x64" `
          --workpath "build/x64" `
          flightpath_ci.spec

        if (Test-Path "dist/x64/${{ env.APP_NAME }}.exe") {
          echo "✅ x64 build successful"
          #Get-ChildItem "dist/x64/${{ env.APP_NAME }}" | Select-Object Name, Length
        } else {
          echo "❌ x64 build failed"
          #Get-ChildItem "dist/x64" -Recurse | Select-Object FullName
          exit 1
        }

    #
    # keep the exe
    #
    - name: Upload signable x64 MSIX artifact
      uses: actions/upload-artifact@v4
      with:
        name: "${{ env.APP_NAME }}.exe"
        path: "source/dist/x64/${{ env.APP_NAME }}.exe"
        retention-days: 30

    - name: Prepare MSIX content
      shell: pwsh
      run: |
        $ws = $env:GITHUB_WORKSPACE
        $stagingDir = "$ws/packaging/msix/staging/x64"
        New-Item -ItemType Directory -Force -Path $stagingDir

        # Copy built application
        Copy-Item -Recurse "$ws/source/dist/x64/*" $stagingDir

        # Copy manifest and assets
        Copy-Item "$ws/packaging/msix/manifest/AppxManifest.xml" "$stagingDir/"
        Copy-Item -Recurse "$ws/packaging/msix/assets" "$stagingDir/"

        # Update manifest with correct architecture and version
        $manifestPath = "$stagingDir/AppxManifest.xml"
        [xml]$manifest = Get-Content $manifestPath
        $manifest.Package.Identity.Version = "${{ steps.get_version.outputs.version }}.0"
        $manifest.Package.Identity.SetAttribute("ProcessorArchitecture", "x64")
        $manifest.Save($manifestPath)

    - name: Create MSIX package
      shell: pwsh
      run: |
        $ws = $env:GITHUB_WORKSPACE
        $stagingDir = "$ws/packaging/msix/staging/x64"
        $outputDir = "$ws/packaging/msix/output"
        New-Item -ItemType Directory -Force -Path $outputDir

        $msixName = "${{ env.APP_NAME }}-x64.msix"
        #$msixName = "${{ env.APP_NAME }}-x64-${{ steps.get_version.outputs.version }}.msix"

        & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\makeappx.exe" pack `
          /d $stagingDir `
          /p "$outputDir/$msixName" `
          /l /o

        if ($LASTEXITCODE -eq 0) {
          echo "✅ x64 MSIX package created: $msixName"
        } else {
          echo "❌ x64 MSIX packaging failed"
          exit 1
        }

    - name: Upload x64 MSIX artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}-x64.msix
        path: packaging/msix/output/*.msix
        retention-days: 30



    #
    # build signable test msix
    #
    - name: Prepare signable MSIX content
      shell: pwsh
      run: |
        $ws = $env:GITHUB_WORKSPACE
        $testingDir = "$ws/packaging/msix/testing/x64"
        New-Item -ItemType Directory -Force -Path $testingDir

        # Copy built application
        Copy-Item -Recurse "$ws/source/dist/x64/*" $testingDir

        # Copy manifest and assets
        Copy-Item "$ws/packaging/msix/manifest/testing/AppxManifest.xml" "$testingDir/"
        Copy-Item -Recurse "$ws/packaging/msix/assets" "$testingDir/"

        # Update manifest with correct architecture and version
        $manifestPath = "$testingDir/AppxManifest.xml"
        [xml]$manifest = Get-Content $manifestPath
        $manifest.Package.Identity.Version = "${{ steps.get_version.outputs.version }}.0"
        $manifest.Package.Identity.SetAttribute("ProcessorArchitecture", "x64")
        $manifest.Save($manifestPath)

    - name: Create signable MSIX package
      shell: pwsh
      run: |
        $ws = $env:GITHUB_WORKSPACE
        $testingDir = "$ws/packaging/msix/testing/x64"
        $outputDir = "$ws/packaging/msix/output"
        New-Item -ItemType Directory -Force -Path $outputDir

        $msixName = "${{ env.APP_NAME }}-test-x64.msix"
        # $msixName = "${{ env.APP_NAME }}-x64-${{ steps.get_version.outputs.version }}-test.msix"

        & "C:\Program Files (x86)\Windows Kits\10\bin\10.0.22621.0\x64\makeappx.exe" pack `
          /d $testingDir `
          /p "$outputDir/$msixName" `
          /l /o

        if ($LASTEXITCODE -eq 0) {
          echo "✅ x64 MSIX package created: $msixName"
        } else {
          echo "❌ x64 MSIX packaging failed"
          exit 1
        }

    - name: Upload signable x64 MSIX artifact
      uses: actions/upload-artifact@v4
      with:
        name: ${{ env.APP_NAME }}-test-x64.msix
        path: packaging/msix/output/${{ env.APP_NAME }}-test-x64.msix
        retention-days: 30
        #path: packaging/msix/output/${{ env.APP_NAME }}-x64-${{ steps.get_version.outputs.version }}-test.msix


